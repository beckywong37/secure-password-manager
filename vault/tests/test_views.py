"""
GenAI Citation for April:
These tests were generated by Cursor using Sonnet 4.5 and reviewed by me.
Since I am learning how to test Django applications, I asked Cursor to provide descriptive docstrings for each test.
The conversation transcript is located in `GenAI_transcripts/2025_11_02_CursorVaultTests.md`

Vault View/API Tests

This module tests the RecordViewSet API endpoints to ensure proper
authentication, authorization, and CRUD operations.

NOTE ON RECORDVIEWSETTESTS VS RECORDVIEWSETJWTAUTHENTICATIONTESTS:
    - RecordViewSetTests bypasses JWT entirely while testing vault business logic, e.g. "Given an authenticated user, does the vault work as intended?"
    - Uses a real JWT token from the auth_service's methods to ensure that the vault works as expected with JWT authentication.

NOTE ON CREATING TEST USERS:
   - Your custom User model requires an auth_key field for login
   - Use create_user_with_auth_key() from test_utils.py to generate proper cryptographic keys without API calls for testing purposes
     This avoids having to call the registration and login APIs and embedding that complexity into the tests, at the cost at not
     being a full integration test.
   - Note: Direct User.objects.create_user() will NOT work for JWT login

"""

from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase
from django.contrib.auth import get_user_model
from django_otp.plugins.otp_totp.models import TOTPDevice
from vault.models import Record
from vault.tests.test_utils import create_user_with_auth_key
from auth_service.utils.mfa import create_signed_token
from unittest.mock import patch

User = get_user_model()


class RecordViewSetTests(APITestCase):
    """
    Test suite for the RecordViewSet API endpoints.

    These tests verify the API behaves correctly with authentication,
    proper data isolation between users, and CRUD operations.
    """

    def setUp(self):
        """
        Setup method that runs before EVERY test.

        Purpose: Create test users and records for testing.

        What's created:
            - user1: Primary test user with 2 records
            - user2: Secondary user with 1 record (for isolation testing)

        Why we need multiple users:
            To test that users can't access each other's data.
        """
        # Create first user
        self.user1 = User.objects.create_user(
            username="user1", email="user1@example.com", password="Password123"
        )

        # Create second user
        self.user2 = User.objects.create_user(
            username="user2", email="user2@example.com", password="Password123"
        )

        # Create records for user1
        self.record1_user1 = Record.objects.create(
            title="GitHub",
            user=self.user1,
            username="user1github",
            password="encrypted_pass1",
            email="user1@github.com",
            url="https://github.com",
            notes="User 1 GitHub",
        )

        self.record2_user1 = Record.objects.create(
            title="Netflix",
            user=self.user1,
            username="user1netflix",
            password="encrypted_pass2",
            email="user1@netflix.com",
            url="https://netflix.com",
            notes="User 1 Netflix",
        )

        # Create record for user2
        self.record1_user2 = Record.objects.create(
            title="Amazon",
            user=self.user2,
            username="user2amazon",
            password="encrypted_pass3",
            email="user2@amazon.com",
            url="https://amazon.com",
            notes="User 2 Amazon",
        )

    def test_list_records_requires_authentication(self):
        """
        Test: Unauthenticated requests to list records are rejected.

        Assumptions:
            - RecordViewSet has permission_classes = [IsAuthenticated]
            - No user is authenticated in this test

        What we're testing:
            - Endpoint requires authentication
            - Unauthenticated requests return 401 Unauthorized

        Expected behavior:
            - Response status is 401 (Unauthorized)
            - No data is returned

        Why this matters:
            Without authentication, ANYONE could see all passwords.
            This test ensures the endpoint is protected.
        """
        url = reverse("record-list")  # /vault/records/
        response = self.client.get(url, format="json")

        # Should be rejected
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_list_records_returns_only_user_records(self):
        """
        Test: Authenticated user only sees their own records, not others'.

        Assumptions:
            - user1 is authenticated
            - user1 has 2 records, user2 has 1 record
            - get_queryset() filters by self.request.user

        What we're testing:
            - User isolation is enforced
            - User1 sees only their 2 records
            - User1 does NOT see user2's record

        Expected behavior:
            - Response status is 200 OK
            - Response contains exactly 2 records
            - Both records belong to user1
            - user2's record is not in the response
        """
        # Authenticate as user1
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-list")
        response = self.client.get(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)

        self.assertEqual(len(response.data), 2)

        # Verify both records belong to user1
        titles = [record["title"] for record in response.data]
        self.assertIn("GitHub", titles)
        self.assertIn("Netflix", titles)
        self.assertNotIn("Amazon", titles)  # user2's record

    def test_create_record_requires_authentication(self):
        """
        Test: Unauthenticated requests to create records are rejected.

        Assumptions:
            - RecordViewSet requires authentication
            - No user is authenticated

        What we're testing:
            - POST requests require authentication
            - Unauthenticated POST returns 401

        Expected behavior:
            - Response status is 401 Unauthorized
            - No record is created in database

        Why this matters:
            Prevents anonymous users from creating records.
        """
        url = reverse("record-list")
        data = {
            "title": "Test",
            "username": "testuser",
            "password": "encrypted_pass",
            "email": "test@example.com",
            "url": "https://example.com",
            "notes": "",
        }

        response = self.client.post(url, data, format="json")

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        self.assertEqual(Record.objects.filter(title="Test").count(), 0)

    def test_create_record_authenticated(self):
        """
        Test: Authenticated user can create a record.

        Assumptions:
            - user1 is authenticated
            - Valid record data is provided
            - perform_create() assigns user automatically

        What we're testing:
            - Authenticated POST creates a record
            - Record is automatically assigned to the authenticated user
            - User field is set by perform_create(), not the request data

        Expected behavior:
            - Response status is 201 Created
            - Record is saved to database
            - Record.user is set to the authenticated user (user1)
            - Response includes the created record data
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-list")
        data = {
            "title": "Spotify",
            "username": "user1spotify",
            "password": "encrypted_spotify_pass",
            "email": "user1@spotify.com",
            "url": "https://spotify.com",
            "notes": "My music account",
        }

        response = self.client.post(url, data, format="json")

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        record = Record.objects.get(title="Spotify")
        self.assertEqual(record.username, "user1spotify")

        # Verify user was set automatically to authenticated user
        self.assertEqual(record.user, self.user1)

    def test_retrieve_own_record(self):
        """
        Test: User can retrieve their own record by ID.

        Assumptions:
            - user1 is authenticated
            - user1 owns record1_user1

        What we're testing:
            - GET /vault/records/{id}/ returns the record
            - User can access their own records by ID

        Expected behavior:
            - Response status is 200 OK
            - Response contains the requested record's data
            - All fields are present and correct
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-detail", kwargs={"pk": self.record1_user1.id})
        response = self.client.get(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)

        self.assertEqual(response.data["title"], "GitHub")
        self.assertEqual(response.data["username"], "user1github")

    def test_cannot_retrieve_other_user_record(self):
        """
        Test: User CANNOT retrieve another user's record.

        Assumptions:
            - user1 is authenticated
            - record1_user2 belongs to user2 (not user1)
            - get_queryset() filters by user

        What we're testing:
            - User isolation at the detail level
            - Attempting to access another user's record fails
            - get_queryset() prevents cross-user access

        Expected behavior:
            - Response status is 404 Not Found
            - Record exists, but is not in user1's queryset
            - get_queryset() filter makes it invisible to user1

        Why this matters:
            CRITICAL SECURITY: Users must not access each other's passwords!
            Even if user1 knows the ID of user2's record, they can't access it.
        """
        self.client.force_authenticate(user=self.user1)

        # Try to access user2's record as user1
        url = reverse("record-detail", kwargs={"pk": self.record1_user2.id})
        response = self.client.get(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    def test_update_own_record(self):
        """
        Test: User can update their own record (full update with PUT).

        Assumptions:
            - user1 is authenticated
            - user1 owns record1_user1
            - All fields are provided (PUT requires full object)

        What we're testing:
            - PUT /vault/records/{id}/ updates the record
            - All fields are updated correctly
            - Record persists changes to database

        Expected behavior:
            - Response status is 200 OK
            - Record is updated in database
            - All new field values are saved
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-detail", kwargs={"pk": self.record1_user1.id})
        data = {
            "title": "GitHub Updated",
            "username": "newusername",
            "password": "new_encrypted_pass",
            "email": "newemail@github.com",
            "url": "https://github.com/newuser",
            "notes": "Updated notes",
        }

        response = self.client.put(url, data, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)

        self.record1_user1.refresh_from_db()
        self.assertEqual(self.record1_user1.title, "GitHub Updated")
        self.assertEqual(self.record1_user1.username, "newusername")

    def test_partial_update_own_record(self):
        """
        Test: User can partially update their own record (with PATCH).

        Assumptions:
            - user1 is authenticated
            - user1 owns record1_user1
            - Only some fields are provided

        What we're testing:
            - PATCH /vault/records/{id}/ updates specific fields
            - Unspecified fields remain unchanged
            - Partial updates work correctly

        Expected behavior:
            - Response status is 200 OK
            - Specified field (notes) is updated
            - Other fields remain unchanged

        Why this matters:
            Users might want to just update the password without
            retyping all other fields.
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-detail", kwargs={"pk": self.record1_user1.id})
        data = {"notes": "Just updated the notes"}

        response = self.client.patch(url, data, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Verify only notes was updated
        self.record1_user1.refresh_from_db()
        self.assertEqual(self.record1_user1.notes, "Just updated the notes")

        # Other fields should be unchanged
        self.assertEqual(self.record1_user1.title, "GitHub")
        self.assertEqual(self.record1_user1.username, "user1github")

    def test_cannot_update_other_user_record(self):
        """
        Test: User CANNOT update another user's record.

        Assumptions:
            - user1 is authenticated
            - record1_user2 belongs to user2
            - get_queryset() filters by user

        What we're testing:
            - User cannot modify other users' records
            - Update attempt returns 404
            - Original record remains unchanged

        Expected behavior:
            - Response status is 404 Not Found
            - user2's record is not modified
            - get_queryset() filter prevents the update
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-detail", kwargs={"pk": self.record1_user2.id})
        data = {"title": "Hacked Title"}

        response = self.client.patch(url, data, format="json")

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        # Verify user2's record was NOT modified
        self.record1_user2.refresh_from_db()
        self.assertEqual(self.record1_user2.title, "Amazon")

    def test_delete_own_record(self):
        """
        Test: User can delete their own record.

        Assumptions:
            - user1 is authenticated
            - user1 owns record1_user1

        What we're testing:
            - DELETE /vault/records/{id}/ removes the record
            - Record is deleted from database
            - Successful deletion returns 204 No Content

        Expected behavior:
            - Response status is 204 No Content
            - Record no longer exists in database
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-detail", kwargs={"pk": self.record1_user1.id})
        response = self.client.delete(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)

        self.assertFalse(
            Record.objects.filter(id=self.record1_user1.id).exists()
        )

    def test_cannot_delete_other_user_record(self):
        """
        Test: User CANNOT delete another user's record.

        Assumptions:
            - user1 is authenticated
            - record1_user2 belongs to user2
            - get_queryset() filters by user

        What we're testing:
            - User cannot delete other users' records
            - Delete attempt returns 404
            - Original record remains in database

        Expected behavior:
            - Response status is 404 Not Found
            - user2's record still exists in database
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-detail", kwargs={"pk": self.record1_user2.id})
        response = self.client.delete(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        self.assertTrue(
            Record.objects.filter(id=self.record1_user2.id).exists()
        )

    def test_switching_authenticated_users(self):
        """
        Test: Different users see different records.

        Assumptions:
            - Can authenticate as different users in same test
            - Each user has their own records

        What we're testing:
            - Same endpoint returns different data for different users
            - Authentication properly switches context
            - Each user's queryset is isolated

        Expected behavior:
            - user1 sees only their records
            - After re-authenticating as user2, see only user2's records
            - No data leakage between users

        Why this matters:
            Comprehensive test of user isolation.
            Simulates multiple users using the app.

        How authentication switching works:
            - force_authenticate(user=X) changes who is "logged in"
            - Each request after that is made as user X
            - Call it again with different user to switch
        """
        # First, authenticate as user1
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-list")
        response = self.client.get(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 2)  # user1's 2 records

        # Now authenticate as user2
        self.client.force_authenticate(user=self.user2)

        response = self.client.get(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)  # user2's 1 record

        # Verify it's user2's record
        self.assertEqual(response.data[0]["title"], "Amazon")

    def test_create_record_with_invalid_data(self):
        """
        Test: Creating record with invalid data returns validation errors.

        Assumptions:
            - user1 is authenticated
            - Invalid data is provided (e.g., bad email format)

        What we're testing:
            - Serializer validation is enforced
            - Invalid data returns 400 Bad Request
            - Error messages are included in response

        Expected behavior:
            - Response status is 400 Bad Request
            - Response contains error details
            - No record is created
        """
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-list")
        data = {
            "title": "Test",
            "username": "testuser",
            "password": "encrypted_pass",
            "email": "not-an-email",  # Invalid email
            "url": "not-a-url",  # Invalid URL
            "notes": "",
        }

        response = self.client.post(url, data, format="json")

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        self.assertIn("email", response.data)
        self.assertIn("url", response.data)

    def test_logout_removes_authentication(self):
        """
        Test: After force_authenticate(user=None), requests are unauthenticated.

        Assumptions:
            - User was previously authenticated
            - Calling force_authenticate(user=None) logs out

        What we're testing:
            - Can simulate logout in tests
            - After logout, requests fail authentication

        Expected behavior:
            - After force_authenticate(user=None), requests return 401
            - Simulates user logging out

        Why this matters:
            Verifies authentication is properly required after logout.

        Note: This doesn't test actual JWT logout (token invalidation),
        just the authentication requirement.
        """
        # First authenticate as user1
        self.client.force_authenticate(user=self.user1)

        url = reverse("record-list")
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Now "logout"
        self.client.force_authenticate(user=None)

        response = self.client.get(url, format="json")

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)


class RecordViewSetJWTAuthenticationTests(APITestCase):

    def setUp(self):
        """
        Setup: Create a user with proper auth_key for JWT authentication tests.

        Why use create_user_with_auth_key() instead of registration API?
            - Faster: No API call overhead
            - Focused: Tests JWT functionality, not registration

        This approach:
            - Generates auth_key using the same functions as registration
            - Creates a user that can successfully login with JWT
            - Keeps tests isolated to JWT authentication concerns

        For testing registration itself, see auth_service.tests
        """
        # Test credentials
        self.username = "jwtuser"
        self.email = "jwt@example.com"
        self.password = "Password123"

        # Create user with proper auth_key using test utility
        self.user = create_user_with_auth_key(
            username=self.username, email=self.email, password=self.password
        )

        # Add confirmed TOTP device
        TOTPDevice.objects.create(user=self.user, name="default", confirmed=True)

    def test_list_records_with_jwt_token(self):
        """
        Test: Access records using real JWT token authentication.

        Assumptions:
            - Auth service provides JWT tokens via /auth/login/
            - JWT token is valid
            - Token is passed in Authorization header

        What we're testing:
            - Real JWT authentication flow
            - Token extraction and validation
            - Access with valid token

        Expected behavior:
            - Login returns access token
            - Requests with token in header succeed
            - Same result as force_authenticate but more realistic
        """
        # Step 1: Login to get JWT token
        login_url = reverse("auth_service:login-api")
        login_data = {"username": self.username, "password": self.password}
        login_response = self.client.post(login_url, login_data, format="json")

        # Verify login succeeded - Need to verify MFA
        self.assertEqual(login_response.status_code, status.HTTP_200_OK)
        self.assertTrue(login_response.cookies.get("mfa-verify-token"))
        self.assertTrue(login_response.data.get("is_mfa_setup"))

        # Step 2: Verify MFA
        vault_key = "06cf04db65c36c16cacc92a657de6bc0729da9e6b73c4342bf842bf58c434b46"
        valid_token = create_signed_token(
            {"user_id": self.user.id, "vault_key": vault_key},
            "mfa-verify",
        )
        self.client.cookies["mfa-verify-token"] = valid_token
        verify_url = reverse("auth_service:mfa-verify-api")
        verify_data = {"mfa_code": "123456"}
        
        with patch.object(TOTPDevice, "verify_token", return_value=True):
            verify_response = self.client.post(verify_url, verify_data, format="json")

        self.assertEqual(verify_response.status_code, status.HTTP_200_OK)
        self.assertIn("access", verify_response.data)
        self.assertIn("refresh", verify_response.data)
        self.assertIn("vault_key", verify_response.data)

        # Step 3: Extract the access token
        token = verify_response.data["access"]

        # Step 4: Create a record to retrieve (using the registered user)
        Record.objects.create(
            title="Test Record",
            user=self.user,
            username="testuser",
            password="encrypted_pass",
            email="test@example.com",
            url="https://example.com",
            notes="",
        )

        # Step 5: Use token to access protected endpoint
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {token}")

        url = reverse("record-list")
        response = self.client.get(url, format="json")

        # Should succeed with valid token
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["title"], "Test Record")

    def test_invalid_token_rejected(self):
        """
        Test: Invalid JWT token is rejected.

        Assumptions:
            - An invalid/fake token is provided
            - JWTAuthentication validates tokens

        What we're testing:
            - Invalid tokens are rejected
            - Security: Can't fake authentication

        Expected behavior:
            - Response status is 401 Unauthorized
            - Access is denied

        Why this matters:
            Users can't fake tokens to access others' data.
        """
        # Use a fake/invalid token
        self.client.credentials(HTTP_AUTHORIZATION="Bearer fake_invalid_token")

        url = reverse("record-list")
        response = self.client.get(url, format="json")

        # Should be rejected
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
