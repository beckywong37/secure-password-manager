"""
GenAI Citation for April:
These tests were generated by Cursor using Sonnet 4.5 and reviewed by me.
Since I am learning how to test Django applications, I asked Cursor to provide descriptive docstrings for each test.
The conversation transcript is located in `GenAI_transcripts/2025_11_02_CursorVaultTests.md`

Vault Model Tests

This module tests the Record model to ensure data integrity and proper database behavior.
"""

from django.test import TestCase
from django.contrib.auth import get_user_model
from vault.models import Record
from django.core.exceptions import ValidationError

User = get_user_model()


class RecordModelTests(TestCase):
    """
    Test suite for the Record model.

    These tests verify that the Record model behaves correctly at the database level.
    """

    def setUp(self):
        """
        Setup method that runs before EVERY test in this class.

        Purpose: Create a test user that can be used across all tests.
        This user exists in the test database and is destroyed after tests complete.
        """
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPassword123",
        )

    def test_create_record_with_valid_data(self):
        """
        Test: Create a Record with all valid fields.

        Assumptions:
            - A user exists in the database (created in setUp)
            - All required fields are provided
            - All field values meet validation requirements

        What we're testing:
            - The Record model can successfully save to the database
            - All fields are stored correctly
            - The record is retrievable from the database

        Expected behavior:
            - Record is created without errors
            - Record can be retrieved from database
            - All field values match what we set
        """
        record = Record.objects.create(
            title="GitHub Account",
            user=self.user,
            username="myusername",
            password="encrypted_password_here",
            email="github@example.com",
            url="https://github.com",
            notes="My GitHub account credentials",
        )

        self.assertIsNotNone(record.id)

        saved_record = Record.objects.get(id=record.id)

        self.assertEqual(saved_record.title, "GitHub Account")
        self.assertEqual(saved_record.username, "myusername")
        self.assertEqual(saved_record.email, "github@example.com")
        self.assertEqual(saved_record.url, "https://github.com")
        self.assertEqual(saved_record.notes, "My GitHub account credentials")
        self.assertEqual(saved_record.user, self.user)

    def test_record_str_method(self):
        """
        Test: The __str__ method returns the record's title.

        Assumptions:
            - A record exists with a title

        What we're testing:
            - The __str__ method (used when printing a record)
            - Verifies it returns the title field

        Expected behavior:
            - str(record) or print(record) returns the title
            - This helps in Django admin and debugging

        Why this matters:
            When you see a Record object in Django admin or print it,
            it will show the title instead of "Record object (1)"
        """
        record = Record.objects.create(
            title="Netflix Account",
            user=self.user,
            username="user@example.com",
            password="encrypted_pass",
            email="user@example.com",
            url="https://netflix.com",
            notes="",
        )

        self.assertEqual(str(record), "Netflix Account")

    def test_record_timestamps(self):
        """
        Test: Records automatically get created_at and updated_at timestamps.

        Assumptions:
            - A record is created
            - Time passes between creation and update

        What we're testing:
            - created_at is set automatically when record is created
            - updated_at is set automatically when record is modified
            - updated_at changes when the record is saved again

        Expected behavior:
            - created_at and updated_at are not None
            - updated_at changes after modifications
            - created_at remains the same

        Why this matters:
            Timestamps help track when passwords were created/updated,
            useful for password rotation policies.
        """
        record = Record.objects.create(
            title="Test Record",
            user=self.user,
            username="testuser",
            password="encrypted_pass",
            email="test@example.com",
            url="https://example.com",
            notes="",
        )

        self.assertIsNotNone(record.created_at)
        self.assertIsNotNone(record.updated_at)

        original_created = record.created_at
        original_updated = record.updated_at

        record.notes = "Updated notes"
        record.save()

        record.refresh_from_db()

        self.assertEqual(record.created_at, original_created)
        self.assertGreater(record.updated_at, original_updated)

    def test_record_user_relationship(self):
        """
        Test: Records are properly linked to users via foreign key.

        Assumptions:
            - Multiple users exist
            - Each user has their own records

        What we're testing:
            - Foreign key relationship between Record and User works
            - Each user can have multiple records
            - Records are accessible via user.records.all()

        Expected behavior:
            - User can access all their records
            - Record count matches what we created
            - Related name 'records' works correctly

        Why this matters:
            This is how we ensure each user only sees their own passwords.
        """
        user2 = User.objects.create_user(
            username="user2", email="user2@example.com", password="Password123"
        )

        # Create records for first user
        Record.objects.create(
            title="Record 1",
            user=self.user,
            username="user1",
            password="pass1",
            email="test@example.com",
            url="https://example1.com",
            notes="",
        )
        Record.objects.create(
            title="Record 2",
            user=self.user,
            username="user2",
            password="pass2",
            email="test@example.com",
            url="https://example2.com",
            notes="",
        )

        # Create record for second user
        Record.objects.create(
            title="Record 3",
            user=user2,
            username="user3",
            password="pass3",
            email="test2@example.com",
            url="https://example3.com",
            notes="",
        )

        # Verify each user has correct number of records
        self.assertEqual(self.user.records.count(), 2)
        self.assertEqual(user2.records.count(), 1)

    def test_record_cascade_delete(self):
        """
        Test: When a user is deleted, their records are also deleted.

        Assumptions:
            - A user exists with records
            - on_delete=models.CASCADE is set on the foreign key

        What we're testing:
            - Cascade deletion works correctly
            - When user is deleted, their records are automatically deleted

        Expected behavior:
            - Deleting a user also deletes all their records
            - No orphaned records remain in the database

        Why this matters:
            This ensures data cleanup. If a user account is deleted,
            their passwords don't remain in the database.
        """
        record = Record.objects.create(
            title="Test Record",
            user=self.user,
            username="testuser",
            password="encrypted_pass",
            email="test@example.com",
            url="https://example.com",
            notes="",
        )

        record_id = record.id

        self.assertTrue(Record.objects.filter(id=record_id).exists())

        self.user.delete()

        self.assertFalse(Record.objects.filter(id=record_id).exists())

    def test_record_with_empty_optional_fields(self):
        """
        Test: Records can be created with empty optional fields.

        Assumptions:
            - Some fields might be optional or can be empty strings
            - Required fields are: title, user, username, password

        What we're testing:
            - Model allows empty values for fields like notes
            - Record can still be saved successfully

        Expected behavior:
            - Record is created even with empty notes
            - Empty fields are stored as empty strings

        Why this matters:
            Users might not always fill in every field (like notes),
            and that should be acceptable.
        """
        record = Record.objects.create(
            title="Minimal Record",
            user=self.user,
            username="minimaluser",
            password="encrypted_pass",
            email="minimal@example.com",
            url="https://minimal.com",
            notes="",  # Empty notes field
        )

        self.assertEqual(record.notes, "")
        self.assertIsNotNone(record.id)

    def test_invalid_email_format(self):
        """
        Test: Invalid email format triggers validation error.

        Assumptions:
            - Django's EmailField validates email format
            - Invalid emails should be rejected

        What we're testing:
            - EmailField validation works at the model level
            - Invalid emails cannot be saved

        Expected behavior:
            - Calling full_clean() with invalid email raises ValidationError
            - Database maintains data integrity

        Why this matters:
            Prevents storing malformed email addresses in the vault.

        Note: Django models don't auto-validate on save() by default.
        You must call full_clean() or the serializer/form does it for you.
        """
        record = Record(
            title="Test Record",
            user=self.user,
            username="testuser",
            password="encrypted_pass",
            email="not-an-email",  # Invalid email format
            url="https://example.com",
            notes="",
        )

        # full_clean() runs all field validators
        with self.assertRaises(ValidationError) as context:
            record.full_clean()

        # Verify the email field has an error
        self.assertIn("email", context.exception.message_dict)

    def test_invalid_url_format(self):
        """
        Test: Invalid URL format triggers validation error.

        Assumptions:
            - Django's URLField validates URL format
            - Invalid URLs should be rejected

        What we're testing:
            - URLField validation works at the model level
            - Invalid URLs cannot be saved (when validated)

        Expected behavior:
            - Calling full_clean() with invalid URL raises ValidationError
            - Database maintains data integrity

        Why this matters:
            Ensures stored URLs are properly formatted and clickable.
        """
        record = Record(
            title="Test Record",
            user=self.user,
            username="testuser",
            password="encrypted_pass",
            email="test@example.com",
            url="not-a-url",  # Invalid URL format
            notes="",
        )

        with self.assertRaises(ValidationError) as context:
            record.full_clean()

        # Verify the url field has an error
        self.assertIn("url", context.exception.message_dict)

    def test_max_length_constraints(self):
        """
        Test: Field max_length constraints are enforced.

        Assumptions:
            - CharField and URLField have max_length=255
            - Exceeding max_length should trigger validation error

        What we're testing:
            - Max length validation on CharField fields
            - Database constraints are properly enforced

        Expected behavior:
            - String longer than 255 characters raises ValidationError
            - Prevents database errors from overly long strings

        Why this matters:
            Prevents database errors and ensures consistent data size limits.
        """
        long_string = "a" * 256  # 256 characters, exceeds 255 limit

        record = Record(
            title=long_string,  # Too long
            user=self.user,
            username="testuser",
            password="encrypted_pass",
            email="test@example.com",
            url="https://example.com",
            notes="",
        )

        with self.assertRaises(ValidationError) as context:
            record.full_clean()

        self.assertIn("title", context.exception.message_dict)
