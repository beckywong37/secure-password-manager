"""
GenAI Citation for April:
These tests were generated by Cursor using Sonnet 4.5 and reviewed by me.
Since I am learning how to test Django applications, I asked Cursor to provide descriptive docstrings for each test.
The conversation transcript is located in `GenAI_transcripts/2025_11_02_CursorVaultTests.md`

Vault Serializer Tests

This module tests the RecordSerializer to ensure proper data transformation
between JSON (API requests/responses) and Django models.
"""

from django.test import TestCase
from django.contrib.auth import get_user_model
from vault.models import Record
from vault.serializers import RecordSerializer

User = get_user_model()


class RecordSerializerTests(TestCase):
    """
    Test suite for the RecordSerializer.

    These tests verify that the serializer correctly transforms data
    between JSON and model instances, and validates input properly.
    """

    def setUp(self):
        """
        Setup method that runs before EVERY test.

        Purpose: Create a test user and a test record.
        These are used across multiple tests.
        """
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPassword123",
        )

        self.record = Record.objects.create(
            title="GitHub",
            user=self.user,
            username="myusername",
            password="encrypted_password",
            email="github@example.com",
            url="https://github.com",
            notes="My GitHub credentials",
        )

    def test_serialization(self):
        """
        Test: Serializer converts a Record model instance to JSON format.

        Assumptions:
            - A Record exists in the database
            - Serializer is configured with correct fields

        What we're testing:
            - RecordSerializer.data returns a dictionary (JSON-like structure)
            - All expected fields are present in the output
            - Field values match the model instance

        Expected behavior:
            - Serializer outputs all fields defined in Meta.fields
            - Auto-generated fields (id, created_at, updated_at) are included
            - Values match the original model
        """
        serializer = RecordSerializer(instance=self.record)
        data = serializer.data

        # Verify all expected fields are present
        expected_fields = [
            "id",
            "title",
            "username",
            "password",
            "email",
            "url",
            "notes",
            "created_at",
            "updated_at",
        ]
        for field in expected_fields:
            self.assertIn(field, data)

        # Verify field values match
        self.assertEqual(data["title"], "GitHub")
        self.assertEqual(data["username"], "myusername")
        self.assertEqual(data["password"], "encrypted_password")
        self.assertEqual(data["email"], "github@example.com")
        self.assertEqual(data["url"], "https://github.com")
        self.assertEqual(data["notes"], "My GitHub credentials")

    def test_deserialization_with_valid_data(self):
        """
        Test: Serializer converts valid JSON to a Record instance.

        Assumptions:
            - Valid JSON data is provided (matches model fields)
            - User exists to assign as foreign key

        What we're testing:
            - Serializer validates incoming data
            - serializer.is_valid() returns True for valid data
            - serializer.save() creates a new Record

        Expected behavior:
            - is_valid() returns True
            - save() creates a Record with correct field values
            - Record is persisted to database
        """
        data = {
            "title": "Netflix",
            "username": "netflixuser",
            "password": "encrypted_netflix_pass",
            "email": "netflix@example.com",
            "url": "https://netflix.com",
            "notes": "Family account",
        }

        # Pass user as context (mimics what the view does)
        serializer = RecordSerializer(data=data)

        # Validate the data
        self.assertTrue(serializer.is_valid())

        # Save and check errors (should be none)
        record = serializer.save(user=self.user)

        # Verify record was created
        self.assertIsNotNone(record.id)
        self.assertEqual(record.title, "Netflix")
        self.assertEqual(record.username, "netflixuser")
        self.assertEqual(record.user, self.user)

    def test_deserialization_with_missing_required_field(self):
        """
        Test: Serializer rejects data missing required fields.

        Assumptions:
            - Required fields: title, username, password, email, url
            - Missing required fields should fail validation

        What we're testing:
            - Serializer validation catches missing fields
            - is_valid() returns False
            - errors dictionary contains the missing field

        Expected behavior:
            - is_valid() returns False
            - serializer.errors contains 'title' field error
            - Error message indicates field is required

        """
        data = {
            # Missing 'title' field
            "username": "netflixuser",
            "password": "encrypted_netflix_pass",
            "email": "netflix@example.com",
            "url": "https://netflix.com",
            "notes": "",
        }

        serializer = RecordSerializer(data=data)

        # Should not be valid
        self.assertFalse(serializer.is_valid())

        # Should have error for title field
        self.assertIn("title", serializer.errors)

    def test_read_only_fields_ignored_on_create(self):
        """
        Test: Read-only fields (id, created_at, updated_at) are ignored in input.

        Assumptions:
            - id, created_at, updated_at are marked as read_only_fields
            - User attempts to set these fields in POST request

        What we're testing:
            - Read-only fields provided in input are ignored
            - Django auto-generates these fields
            - Serializer doesn't allow user to override these values

        Expected behavior:
            - Serializer is valid even with read-only fields in input
            - Created record has auto-generated values, not user-provided ones
            - id is assigned by database, timestamps are auto-generated

        Why this matters:
            Security: Users shouldn't control IDs or timestamps.
            These are system-managed fields.
        """
        data = {
            "id": 9999,  # User tries to set ID (should be ignored)
            "title": "Test Record",
            "username": "testuser",
            "password": "encrypted_pass",
            "email": "test@example.com",
            "url": "https://example.com",
            "notes": "",
            "created_at": "2020-01-01T00:00:00Z",  # Should be ignored
            "updated_at": "2020-01-01T00:00:00Z",  # Should be ignored
        }

        serializer = RecordSerializer(data=data)

        self.assertTrue(serializer.is_valid())
        record = serializer.save(user=self.user)

        # ID should be auto-generated, not 9999
        self.assertNotEqual(record.id, 9999)

        # Timestamps should be recent, not 2020
        from django.utils import timezone
        import datetime

        self.assertGreater(
            record.created_at,
            datetime.datetime(2020, 1, 2, tzinfo=datetime.timezone.utc),
        )

    def test_read_only_fields_included_in_output(self):
        """
        Test: Read-only fields are included when serializing (model â†’ JSON).

        Assumptions:
            - Read-only fields should appear in API responses
            - They're only read-only for input, not output

        What we're testing:
            - Serializer includes id, created_at, updated_at in output
            - These fields have values (not None)

        Expected behavior:
            - serializer.data contains read-only fields
            - Values are present and correct
        """
        serializer = RecordSerializer(instance=self.record)
        data = serializer.data

        # Read-only fields should be in output
        self.assertIn("id", data)
        self.assertIn("created_at", data)
        self.assertIn("updated_at", data)

        self.assertIsNotNone(data["id"])
        self.assertIsNotNone(data["created_at"])
        self.assertIsNotNone(data["updated_at"])

    def test_invalid_email_validation(self):
        """
        Test: Serializer validates email field format.

        Assumptions:
            - Email field should contain valid email format
            - Invalid emails should fail validation

        What we're testing:
            - Serializer's email validation
            - is_valid() returns False for invalid emails
            - Error message is appropriate

        Expected behavior:
            - is_valid() returns False
            - serializer.errors contains 'email' field error
            - Error indicates invalid email format

        Why this matters:
            Prevents storing malformed emails in the vault.
            API returns 400 with validation error.
        """
        data = {
            "title": "Test",
            "username": "testuser",
            "password": "encrypted_pass",
            "email": "not-an-email",  # Invalid format
            "url": "https://example.com",
            "notes": "",
        }

        serializer = RecordSerializer(data=data)

        self.assertFalse(serializer.is_valid())
        self.assertIn("email", serializer.errors)

    def test_invalid_url_validation(self):
        """
        Test: Serializer validates URL field format.

        Assumptions:
            - URL field should contain valid URL format
            - Invalid URLs should fail validation

        What we're testing:
            - Serializer's URL validation
            - is_valid() returns False for invalid URLs
            - Error message is appropriate

        Expected behavior:
            - is_valid() returns False
            - serializer.errors contains 'url' field error
            - Error indicates invalid URL format

        Why this matters:
            Ensures URLs are properly formatted and clickable.
            Prevents malformed URLs in the vault.
        """
        data = {
            "title": "Test",
            "username": "testuser",
            "password": "encrypted_pass",
            "email": "test@example.com",
            "url": "not-a-url",  # Invalid format
            "notes": "",
        }

        serializer = RecordSerializer(data=data)

        self.assertFalse(serializer.is_valid())
        self.assertIn("url", serializer.errors)

    def test_partial_update(self):
        """
        Test: Serializer supports partial updates (PATCH requests).

        Assumptions:
            - Record exists in database
            - Only some fields are being updated
            - Other fields should remain unchanged

        What we're testing:
            - Serializer with partial=True allows updating specific fields
            - Unspecified fields remain unchanged
            - Updated fields are saved correctly

        Expected behavior:
            - partial=True allows incomplete data
            - Only specified fields are updated
            - Other fields retain original values

        Why this matters:
            PATCH /vault/records/{id}/ allows updating just one field
            (e.g., just update the password, keep everything else the same)
        """
        # Only update the notes field
        data = {"notes": "Updated notes here"}

        serializer = RecordSerializer(
            instance=self.record,
            data=data,
            partial=True,  # Allows partial updates
        )

        self.assertTrue(serializer.is_valid())
        updated_record = serializer.save()

        # Notes should be updated
        self.assertEqual(updated_record.notes, "Updated notes here")

        # Other fields should remain unchanged
        self.assertEqual(updated_record.title, "GitHub")
        self.assertEqual(updated_record.username, "myusername")

    def test_full_update(self):
        """
        Test: Serializer supports full updates (PUT requests).

        Assumptions:
            - Record exists in database
            - All fields are being updated
            - partial=False (default)

        What we're testing:
            - Serializer can update all fields at once
            - All new values are saved correctly

        Expected behavior:
            - All fields are updated with new values
            - Record is persisted to database

        Why this matters:
            PUT /vault/records/{id}/ replaces entire record.
            All fields must be provided.
        """
        data = {
            "title": "Updated GitHub",
            "username": "newusername",
            "password": "new_encrypted_pass",
            "email": "newemail@example.com",
            "url": "https://github.com/newrepo",
            "notes": "Completely updated",
        }

        serializer = RecordSerializer(instance=self.record, data=data)

        self.assertTrue(serializer.is_valid())
        updated_record = serializer.save()

        # All fields should be updated
        self.assertEqual(updated_record.title, "Updated GitHub")
        self.assertEqual(updated_record.username, "newusername")
        self.assertEqual(updated_record.password, "new_encrypted_pass")
        self.assertEqual(updated_record.email, "newemail@example.com")
        self.assertEqual(updated_record.url, "https://github.com/newrepo")
        self.assertEqual(updated_record.notes, "Completely updated")

    def test_user_field_not_in_serializer_fields(self):
        """
        Test: User field is NOT included in serializer input/output.

        Assumptions:
            - User field is not listed in Meta.fields
            - User is assigned automatically by the view

        What we're testing:
            - Serializer doesn't expose user field in JSON
            - User cannot be set via API request
            - User is set by view's perform_create()

        Expected behavior:
            - 'user' not in serializer.data (output)
            - User cannot override which user owns a record

        Why this matters:
            Security: Users should only create records for themselves.
            User is determined by JWT token, not request data.
            Prevents user A from creating records for user B.
        """
        serializer = RecordSerializer(instance=self.record)
        data = serializer.data

        # User field should NOT be in the serialized output
        self.assertNotIn("user", data)

        # Attempting to set user in input should be ignored
        input_data = {
            "title": "Test",
            "user": 999,  # Trying to set user (should be ignored)
            "username": "testuser",
            "password": "encrypted_pass",
            "email": "test@example.com",
            "url": "https://example.com",
            "notes": "",
        }

        serializer = RecordSerializer(data=input_data)
        self.assertTrue(serializer.is_valid())

        # User field is not validated because it's not in Meta.fields
        self.assertNotIn("user", serializer.validated_data)
